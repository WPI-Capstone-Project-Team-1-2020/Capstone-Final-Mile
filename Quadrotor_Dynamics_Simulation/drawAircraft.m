
function drawAircraft(uu)

    % process inputs to function
    pn       = uu(1);       % inertial North position     
    pe       = uu(2);       % inertial East position
    pd       = uu(3);           
    u        = uu(4);       
    v        = uu(5);       
    w        = uu(6);       
    phi      = uu(7);       % roll angle         
    theta    = uu(8);       % pitch angle     
    psi      = uu(9);       % yaw angle     
    p        = uu(10);       % roll rate
    q        = uu(11);       % pitch rate     
    r        = uu(12);       % yaw rate    
    t        = uu(13);       % time

    % define persistent variables 
    persistent ax
    persistent vehicle_handle
    persistent Vertices
    persistent Faces
    persistent facecolors
    persistent Vertices2
    persistent Faces2
    persistent facecolors2
    
    % first time function is called, initialize plot and persistent vars
    if t==0
        figure(1),clf

        ax = axes('XLim',[-500,500], 'YLim',[-500,500], 'ZLim',[-10,600]);
        view(32,47)  % set the vieew angle for figure
        grid on
        axis manual
        
        title('Vehicle')
        xlabel('East')
        ylabel('North')
        zlabel('Down')

        [Vertices,Faces,facecolors,Vertices2,Faces2,facecolors2] = defineVehicleBody;
        

        vehicle_handle = drawVehicleBody(ax,Vertices,Faces,facecolors,...
                                            Vertices2,Faces2,facecolors2,...
                                            pn,pe,pd,phi,theta,psi,...
                                            [],'normal');
                
    % at every other time step, redraw base and rod
    else 
            drawVehicleBody(ax,Vertices,Faces,facecolors,...
                        Vertices2, Faces2, facecolors2,...
                        pn,pe,pd,phi,theta,psi,...
                        vehicle_handle);
    end
end

  
%=======================================================================
% drawVehicle
% return handle if 3rd argument is empty, otherwise use 3rd arg as handle
%=======================================================================
%
function handle = drawVehicleBody(ax,V,F,patchcolors,...
                                     V2,F2,patchcolors2,...
                                     pn,pe,pd,phi,theta,psi,...
                                     handle,mode)
                
  M = rotate(phi, theta, psi);  % rotate vehicle
  M = translate(M, pn, pe, pd);  % translate vehicle  
  % transform vertices from NED to XYZ (for matlab rendering)
  R = [...
      0, -1, 0, 0;...
      1, 0, 0, 0;...
      0, 0, 1, 0;...
      0, 0, 0, 1;...
      ];
  M = R*M';

    if isempty(handle)
        handles(1) = patch('Vertices', V','Faces', F,...
                    'FaceVertexCData',patchcolors,...
                    'FaceColor','flat',...
                    'EraseMode', mode);
        handles(2) = patch('Vertices', V2','Faces', F2,...
                     'FaceVertexCData',patchcolors2,...
                     'FaceColor','flat',...
                     'EraseMode', mode);
        set(handles,'Clipping','off');
        handle = hgtransform('Parent', ax);
        set(handles,'Parent',handle);
        set(gcf,'Renderer','opengl');
        drawnow;
    else
        set(handle,'Matrix',M);
        drawnow
    end
end

%%%%%%%%%%%%%%%%%%%%%%%
function R=rotate(phi,theta,psi)

  % define rotation matrix (right handed)
  R_roll = [...
          1, 0, 0, 0;...
          0, cos(phi), sin(phi), 0;...
          0, -sin(phi), cos(phi), 0;...
          0, 0, 0, 1];
  R_pitch = [...
          cos(theta), 0, -sin(theta), 0;...
          0, 1, 0, 0;...
          sin(theta), 0, cos(theta), 0;...
          0, 0, 0, 1];
  R_yaw = [...
          cos(psi), sin(psi), 0, 0;...
          -sin(psi), cos(psi), 0, 0;...
          0, 0, 1, 0;...
          0, 0, 0, 1];
  R = R_roll*R_pitch*R_yaw; 
    % note that R above either leaves the vector alone or rotates
    % a vector in a left handed rotation.  We want to rotate all
    % points in a right handed rotation, so we must transpose
end
% end rotateVert

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% translate vertices by pn, pe, pd
function M = translate(M,pn,pe,pd)

  M = M*[1, 0, 0, 0; 0, 1, 0, 0; 0, 0, 1, 0; pn, pe, pd, 1];
  
end

% end translate

%=======================================================================
% defineVehicleBody
%=======================================================================
function [V,F,facecolors,V2,F2,facecolors2] = defineVehicleBody

    % Generate the geometry used to draw the quadcopter
    r = .5; d = 1.25; h = .25; %inches: rotor dia., quad motor distance from 
    % center of mass, and rotor height above arms (entirely cosmetic)

    % Construct rotor representations
    N = [d  0 h].';% m1 rotor center [X Y Z]
    E = [0 -d h].';% m4 rotor center
    W = [0  d h].';% m2 rotor center
    S = [-d 0 h].';% m3 rotor center
    Nr = circlePoints(N, r, 10); Nr = [Nr Nr(:,1)]; % Rotor blade circles
    Er = circlePoints(E, r, 10); Er = [Er Er(:,1)];
    Wr = circlePoints(W, r, 10); Wr = [Wr Wr(:,1)];
    Sr = circlePoints(S, r, 10); Sr = [Sr Sr(:,1)];

    % Define the vertices (physical location of vertices
    V = [...
        -d, 0, 0;...      % pt 1
        d,  0, 0;...      % pt 2
        0, h/4, h/4;...   % pt 3
        0, -h/4, h/4;...  % pt 4
        0, h/4, -h/4;...  % pt 5
        0, -h/4, -h/4;... % pt 6
        0, h/4, h/4;...   % pt 7
        0, h/4, -h/4;...  % pt 8
        0, -h/4, h/4;...  % pt 9
        0, -h/4, -h/4;... % pt 10
        0, -d, 0;...      % pt 11
        0,  d, 0;...      % pt 12
        h/4, 0, h/4;...   % pt 13
        -h/4, 0, h/4;...  % pt 14
        h/4, 0, -h/4;...  % pt 15
        -h/4, 0, -h/4;... % pt 16
        h/4, 0, h/4;...   % pt 17
        h/4, 0, -h/4;...  % pt 18
        -h/4, 0, h/4;...  % pt 19
        -h/4, 0, -h/4;... % pt 20
    ]';

    V = V*15;

    V2 = [ ...
        Nr,...
        Er,...
        Wr,...
        Sr,...
    ];

    V2 = V2*15;

% define faces as a list of vertices numbered above
  F = [...
        1, 3, 4;...   
        1, 5, 6;...
        1, 7, 8;...
        1, 9, 10;...
        2, 3, 4;...   
        2, 5, 6;...
        2, 7, 8;...
        2, 9, 10;...
        11, 13, 14;...   
        11, 15, 16;...
        11, 17, 18;...
        11, 19, 20;...
        12, 13, 14;...   
        12, 15, 16;...
        12, 17, 18;...
        12, 19, 20;...
       ];
   
   F2 = [ ...
       1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11;...
       12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22;...
       23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33;...
       34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44;...
       ];

% define colors for each face    
  myred = [1, 0, 0];
  mygreen = [0, 1, 0];
  myblue = [0, 0, 1];
  myyellow = [1, 1, 0];
  mycyan = [0, 1, 1];

  facecolors = [...
    mygreen;...    
    mygreen;...    
    mygreen;...    
    mygreen;...    
    myred;...     
    myred;...     
    myred;...     
    myred;...     
    mygreen;...    
    mygreen;...    
    mygreen;...    
    mygreen;...    
    myred;...     
    myred;...     
    myred;...     
    myred;...     
    ];

    facecolors2 = [...
        mycyan; ...
        mycyan; ...
        mycyan; ...
        mycyan; ...
     ];
end

function points = circlePoints(center, radius, numberOfPoints)
% Helper function for plotting points
% Inspired by "circle()" from Peter Corke's MATLAB Robotics Toolbox
c = center.'; % [x;y] location of center
r = radius;
n = numberOfPoints;
% compute points around the circumference
th = (0:n-1)'/n*2*pi; % angles coresponding to each point
x = r*cos(th) + c(1); % x part
y = r*sin(th) + c(2); % y part
points = [x,y].';
    if length(c) > 2
        z = ones(size(x))*c(3); % z part
        points = [x, y, z].';
    end
end